{
	"batch": {
		"batch": "batch",
		"concat": {
			"topic": "topic",
			"topics-label": "Topics"
		},
		"count": {
			"count": "conteggio",
			"invalid": "Conteggio e sovrapposizione non validi",
			"label": "Numero di messaggi",
			"overlap": "Sovrapposizione"
		},
		"interval": {
			"empty": "inviare un messaggio vuoto quando non arriva alcun messaggio",
			"label": "Intervallo",
			"seconds": "secondi"
		},
		"mode": {
			"concat": "Concatenare sequenze",
			"interval": "Raggruppa per intervallo di tempo",
			"label": "Modalità",
			"num-msgs": "Raggruppa per numero di messaggi"
		},
		"no-parts": "nessuna proprietà parts nel messaggio",
		"too-many": "troppi messaggi in sospeso nel nodo batch",
		"unexpected": "modalità imprevista"
	},
	"catch": {
		"catch": "cattura: tutti",
		"catchNodes": "cattura: __number__",
		"catchUncaught": "cattura: altri non catturati",
		"label": {
			"selectAll": "seleziona tutto",
			"source": "Cattura gli errori da",
			"uncaught": "Ignorare gli errori gestiti da altri nodi Catch"
		},
		"scope": {
			"all": "tutti i nodi",
			"selected": "i nodi selezionati"
		}
	},
	"change": {
		"action": {
			"change": "Modifica",
			"delete": "Elimina",
			"move": "Sposta",
			"replace": "Sostituire con",
			"search": "Cerca",
			"set": "Imposta",
			"to": "in"
		},
		"errors": {
			"invalid-expr": "Espressione JSONata non valida: __error__",
			"invalid-from": "Proprietà 'from' non valida: __error__",
			"invalid-json": "Proprietà JSON 'to' non valida",
			"no-override": "Impossibile impostare la proprietà di tipo non oggetto: __property__"
		},
		"label": {
			"change": "cambia __property__",
			"changeCount": "modifica: __count__ regole",
			"delete": "elimina __property__",
			"move": "sposta __property__",
			"regex": "Usare espressioni regolari",
			"rule": "regola",
			"rules": "Regole",
			"set": "imposta __property__"
		}
	},
	"comment": {
		"comment": "commento"
	},
	"common": {
		"errors": {
			"nooverride": "Avviso: le proprietà msg non possono più eseguire la sovrascrittura delle proprietà del nodo. Vedi bit.ly/nr-override-msg-props"
		},
		"label": {
			"expand": "Espandi",
			"name": "Nome",
			"password": "Password",
			"payload": "Payload",
			"property": "Proprietà",
			"selectNodes": "Selezionare i nodi...",
			"topic": "Topic",
			"username": "Nome utente"
		},
		"notification": {
			"error": "<strong>Errore:</strong>__message__",
			"errors": {
				"no-response": "nessuna risposta dal server",
				"not-deployed": "nodo non distribuito",
				"unexpected": "errore imprevisto (__status__) __message__"
			}
		},
		"status": {
			"connected": "connesso",
			"connecting": "connessione",
			"disconnected": "disconnesso",
			"error": "errore",
			"not-connected": "non connesso",
			"ok": "OK"
		}
	},
	"complete": {
		"completeNodes": "completo: __number__"
	},
	"csv": {
		"errors": {
			"bad_csv": "Dati CSV errati - l'output è probabilmente danneggiato.",
			"csv_js": "Questo nodo gestisce solo stringhe CSV o oggetti js.",
			"obj_csv": "Nessun modello di colonna specificato per l'oggetto -> CSV."
		},
		"hdrout": {
			"all": "inviare sempre intestazioni di colonna",
			"none": "non inviare mai intestazioni di colonna",
			"once": "inviare intestazioni una volta, fino a msg.reset"
		},
		"label": {
			"c2o": "Opzioni da CSV a oggetto",
			"columns": "Colonne",
			"firstrow": "la prima riga contiene i nomi delle colonne",
			"include_empty_strings": "includere stringhe vuote",
			"include_null_values": "includere valori Null",
			"includerow": "includere la riga dei nomi di colonne",
			"input": "Input",
			"newline": "Nuova riga",
			"o2c": "Opzioni da oggetto a CSV",
			"output": "Output",
			"separator": "Separatore",
			"skip-e": "linee",
			"skip-s": "Salta le prime",
			"usestrings": "analizzare i valori numerici"
		},
		"newline": {
			"linux": "Linux (\\n)",
			"mac": "Mac (\\r)",
			"windows": "Windows (\\r\\n)"
		},
		"output": {
			"array": "un singolo messaggio [array]",
			"row": "un messaggio per riga"
		},
		"placeholder": {
			"columns": "nomi delle colonne separati da virgole"
		},
		"separator": {
			"colon": "due punti",
			"comma": "virgola",
			"hashtag": "hashtag",
			"other": "altro...",
			"semicolon": "punto e virgola",
			"space": "spazio",
			"tab": "tabulazione"
		}
	},
	"debug": {
		"autostatus": "uguale all'output di debug",
		"debtab": "scheda debug",
		"invalid-exp": "Espressione JSONata non valida: __error__",
		"messageMenu": {
			"clearFilter": "Annulla il filtro",
			"clearPinned": "Cancellare i percorsi aggiunti",
			"collapseAll": "Comprimi tutti i percorsi",
			"filterNode": "Filtrare questo nodo"
		},
		"msgobj": "oggetto msg completo",
		"msgprop": "proprietà message",
		"none": "Esente",
		"notification": {
			"activated": "Attivato correttamente: __label__",
			"deactivated": "Disattivato correttamente: __label__"
		},
		"output": "Output",
		"severity": "Livello",
		"sidebar": {
			"clearLog": "Cancella log",
			"copyPath": "Copia il percorso",
			"copyPayload": "Copia valore",
			"debugNodes": "Nodi di debug",
			"filterAll": "tutti i nodi",
			"filterCurrent": "flusso corrente",
			"filterLog": "Filtra log",
			"filterSelected": "nodi selezionati",
			"label": "debug",
			"name": "Debug dei messaggi",
			"openWindow": "Apri in una nuova finestra",
			"pinPath": "Pin aperto"
		},
		"status": "stato",
		"tabcon": "scheda debug e console",
		"to": "A",
		"toConsole": "console di sistema",
		"toSidebar": "finestra di debug",
		"toStatus": "stato nodo (32 caratteri)"
	},
	"delay": {
		"action": "Azione",
		"allowrate": "consentire a Msg.rate (in ms) di ignorare la frequenza",
		"and": "e",
		"between": "Tra",
		"day": "Giorno",
		"days": "Giorni",
		"delayfixed": "Ritardo fisso",
		"delaymsg": "Ritardare ogni messaggio",
		"delayvarmsg": "Ignorare il ritardo con msg.delay",
		"dropmsg": "ignora i messaggi intermedi",
		"errors": {
			"too-many": "troppi messaggi in sospeso nel nodo ritardo"
		},
		"fairqueue": "Invia ogni topic a turno",
		"for": "Per",
		"hour": "Ora",
		"hours": "Ore",
		"label": {
			"delay": "ritardo",
			"limit": "limite",
			"limitTopic": "limite topic",
			"random": "casuale",
			"units": {
				"day": {
					"plural": "Giorni",
					"singular": "Giorno"
				},
				"hour": {
					"plural": "Ore",
					"singular": "Ora"
				},
				"minute": {
					"plural": "Minuti",
					"singular": "Minuto"
				},
				"second": {
					"plural": "Secondi",
					"singular": "Secondo"
				}
			},
			"variable": "variabile"
		},
		"limitall": "Tutti i messaggi",
		"limitrate": "Limita frequenza",
		"limittopic": "Per ogni msg.topic",
		"milisecs": "Millisecondi",
		"min": "Minuto",
		"mins": "Minuti",
		"msgper": "msg(i) ogni",
		"randomdelay": "Ritardo casuale",
		"rate": "Frequenza",
		"sec": "Secondo",
		"secs": "Secondi",
		"timedqueue": "Invia tutti i topic"
	},
	"exec": {
		"exec": "exec",
		"label": {
			"append": "Aggiungere",
			"command": "Comando",
			"retcode": "codice uscita",
			"return": "Output",
			"seconds": "secondi",
			"stderr": "stderr",
			"stdout": "stdout",
			"timeout": "Timeout",
			"timeoutplace": "opzionale",
			"winHide": "Nascondi console"
		},
		"oldrc": "Usare l'output vecchio stile (modalità compatibilità)",
		"opt": {
			"exec": "al termine del comando - modalità exec",
			"spawn": "mentre il comando è in esecuzione - modalità spawn"
		},
		"placeholder": {
			"extraparams": "parametri di input aggiuntivi"
		},
		"spawn": "spawn"
	},
	"file": {
		"action": {
			"append": "aggiungi al file",
			"delete": "cancella file",
			"overwrite": "sovrascrivi il file"
		},
		"encoding": {
			"chinese": "Cinese",
			"ibm": "Tabelle codici IBM",
			"iso": "Tabelle codici ISO",
			"japanese": "Giapponese",
			"koi8": "Tabelle codici KOI8",
			"korean": "Coreano",
			"mac": "Tabelle codici Mac",
			"misc": "Varie",
			"native": "Nativo",
			"none": "predefinito",
			"setbymsg": "impostato da msg.encoding",
			"taiwan": "Taiwan/Hong Kong",
			"unicode": "Unicode",
			"windows": "Tabelle codici di Windows"
		},
		"errors": {
			"appendfail": "impossibile aggiungere al file: __error__",
			"createfail": "impossibile creare il file: __error__",
			"deletefail": "impossibile eliminare il file: __error__",
			"invaliddelete": "Avviso: eliminazione non valida. Utilizzare un'opzione di eliminazione specifica nella finestra di dialogo di configurazione.",
			"nofilename": "Nessun nome file specificato",
			"writefail": "impossibile scrivere nel file: __error__"
		},
		"label": {
			"action": "Azione",
			"addnewline": "Aggiungi nuova riga (\\n) ad ogni payload utile?",
			"allProps": "includere tutte le proprietà esistenti in ogni msg",
			"binaryBuffer": "buffer binario",
			"binaryBuffer_plural": "buffer binari",
			"breakchunks": "Rompere in blocchi",
			"breaklines": "Suddividi in linee",
			"createdir": "Creare la cartella se non esiste?",
			"deletelabel": "cancella file",
			"encoding": "Codifica",
			"filelabel": "file",
			"filename": "Nome del file",
			"outputas": "Output",
			"sendError": "Invia messaggio su errore (modalità legacy)",
			"utf8String": "Stringa UTF8",
			"utf8String_plural": "Stringhe UTF8"
		},
		"output": {
			"buffer": "un singolo oggetto Buffer",
			"lines": "un msg per riga",
			"stream": "un flusso di buffer",
			"utf8": "una singola stringa UTF8"
		},
		"status": {
			"appendedfile": "aggiunto al file: __file__",
			"deletedfile": "file cancellato: __file__",
			"wrotefile": "scritto nel file: __file__"
		},
		"tip": "Suggerimento: il nome file deve essere un percorso assoluto, altrimenti sarà relativo alla directory di lavoro del processo di Node-RED."
	},
	"function": {
		"error": {
			"externalModuleLoadError": "Nodo funzione impossibile caricare moduli esterni",
			"externalModuleNotAllowed": "Nodo funzione non autorizzato a caricare moduli esterni",
			"inputListener": "Impossibile aggiungere listener all'evento 'input' all'interno della funzione",
			"moduleLoadError": "Impossibile caricare il modulo __module__: __error__",
			"moduleNameError": "Nome variabile modulo non valido: __name__",
			"moduleNameReserved": "Nome variabile riservato: __name__",
			"moduleNotAllowed": "Il __module__ modulo non è consentito",
			"non-message-returned": "La funzione ha tentato di inviare un messaggio di tipo __type__"
		},
		"function": "",
		"label": {
			"finalize": "Alla fine",
			"function": "Al messaggio",
			"initialize": "All'avvio",
			"modules": "Moduli",
			"outputs": "Outputs",
			"setup": "Configura"
		},
		"require": {
			"importAs": "Importa come",
			"module": "modulo",
			"moduleName": "Nome modulo",
			"var": "variabile"
		},
		"text": {
			"finalize": "// Il codice aggiunto qui verrà eseguito quando il\n// nodo viene arrestato o ridistribuiti.\n",
			"initialize": "// Il codice aggiunto qui verrà eseguito una volta\n// ogni volta che il nodo viene avviato.\n"
		}
	},
	"html": {
		"format": {
			"multi": "come più messaggi, uno per ogni elemento",
			"single": "come un singolo messaggio contenente un array"
		},
		"label": {
			"in": "in",
			"output": "Output",
			"select": "Selettore"
		},
		"output": {
			"attr": "oggetto di qualsiasi attributo degli elementi",
			"html": "il contenuto html degli elementi",
			"text": "solo il contenuto di testo degli elementi"
		}
	},
	"httpin": {
		"basic": "autenticazione di base",
		"basicauth": "Usare l'autenticazione",
		"bearer": "autenticazione bearer",
		"binary": "un buffer binario",
		"digest": "autenticazione digest",
		"errors": {
			"deprecated-call": "Chiamata deprecata a __method__",
			"invalid-payload": "Payload non valido",
			"invalid-transport": "richiesta di trasporto non-http",
			"json-error": "Errore di analisi JSON",
			"missing-path": "percorso mancante",
			"no-response": "Nessun oggetto risposta",
			"no-url": "Nessun URL specificato",
			"not-created": "Impossibile creare il nodo http-in quando httpNodeRoot è impostato su falso",
			"timeout-isnan": "Il valore di timeout non è un numero valido, ignorato",
			"timeout-isnegative": "Il valore di timeout è negativo, ignorato"
		},
		"httpreq": "richiesta http",
		"json": "un oggetto JSON",
		"label": {
			"authType": "Tipo",
			"bearerToken": "Token",
			"binaryBuffer": "buffer binario",
			"doc": "Docs",
			"headers": "Intestazioni",
			"jsonObject": "oggetto JSON analizzato",
			"method": "Metodo",
			"other": "altro",
			"paytoqs": {
				"body": "Invia come corpo della richiesta",
				"ignore": "Ignora",
				"query": "Aggiungi ai parametri della stringa di query"
			},
			"return": "Ritorno",
			"status": "Codice stato",
			"upload": "Accettare caricamenti di file?",
			"url": "URL",
			"utf8String": "Stringa UTF8"
		},
		"noproxy-hosts": "Ignora hosts",
		"persist": "Abilitare il keep-alive della connessione",
		"proxy-config": "Configurazione proxy",
		"setby": "- impostato da msg.method -",
		"status": {
			"requesting": "richiesta"
		},
		"tip": {
			"in": "L'url sarà relativo a ",
			"req": "Suggerimento: se l'analisi JSON non riesce, la stringa recuperata viene restituita così com'è.",
			"res": "I messaggi inviati a questo nodo <b>devono</b> provenire da un nodo d i<i>input http</i>"
		},
		"tls-config": "Configurazione TLS",
		"use-proxy": "Usa proxy",
		"use-proxyauth": "Utilizzare l'autenticazione proxy",
		"use-tls": "Abilitare la connessione protetta (SSL/TLS)",
		"utf8": "una stringa UTF-8"
	},
	"inject": {
		"and": "e le",
		"at": "alle",
		"between": "tra le",
		"crontab": "crontab = __crontab__",
		"days": [
			"Lunedì",
			"Martedì",
			"Mercoledì",
			"Giovedì",
			"Venerdì",
			"Sabato",
			"Domenica"
		],
		"errors": {
			"failed": "inietto non riuscito, vedi i log per i dettagli",
			"invalid-expr": "Espressione JSONata non valida: __error__",
			"toolong": "Intervallo troppo grande"
		},
		"every": "ogni",
		"failed": "Inietto non riuscito: __error__",
		"hours": "ore",
		"inject": "inietta",
		"injectNow": "inietta ora",
		"interval": "intervallo",
		"interval-time": "intervallo tra due tempi",
		"label": {
			"Array": "array",
			"bin": "buffer",
			"bool": "booleano",
			"boolean": "booleano",
			"date": "timestamp",
			"env": "variabile env",
			"flow": "contesto di flusso",
			"global": "contesto globale",
			"invalid": "Oggetto JSON non valido",
			"json": "object",
			"num": "numero",
			"number": "numero",
			"object": "object",
			"properties": "Proprietà",
			"repeat": "Ripeti",
			"str": "stringa",
			"string": "stringa"
		},
		"minutes": "minuti",
		"none": "no",
		"on": "il",
		"onceDelay": "secondi, poi",
		"onstart": "Inietta una volta dopo",
		"previous": "valore precedente",
		"repeat": "ripeti = __repeat__",
		"seconds": "secondi",
		"stopped": "fermato",
		"success": "Iniettato con successo: __label__",
		"time": "in un momento specifico",
		"timestamp": "timestamp"
	},
	"join": {
		"afterCount": "Dopo una serie di parti del messaggio",
		"afterTimeout": "Dopo un timeout a seguito del primo messaggio",
		"combine": "Combina ogni",
		"complete": "Dopo un messaggio con la <code>msg.complete</code> proprietà impostata",
		"completeMessage": "messaggio completo",
		"count": "conteggio",
		"create": "per creare",
		"errors": {
			"invalid-expr": "Espressione JSONata non valida: __error__",
			"invalid-type": "Impossibile aggiungere __error__ al buffer"
		},
		"join": "unisci",
		"joinedUsing": "uniti utilizzando",
		"key": "come chiave",
		"merge": {
			"on-change": "Inviare un messaggio unito all'arrivo di un nuovo topic",
			"topic": "topic",
			"topics": "topics",
			"topics-label": "Topics Uniti"
		},
		"mode": {
			"auto": "automatica",
			"custom": "manuale",
			"merge": "unire sequenze",
			"mode": "Modalità",
			"reduce": "ridurre la sequenza"
		},
		"reduce": {
			"exp": "Ridurre l'exp",
			"exp-value": "exp",
			"fixup": "Exp di correzione",
			"init": "Valore iniziale",
			"right": "Valuta in ordine inverso (dall'ultimo al primo)"
		},
		"seconds": "secondi",
		"send": "Invia messaggio:",
		"subsequent": "e ogni messaggio successivo.",
		"tip": "Questa modalità presuppone che questo nodo sia associato a un nodo <i>diviso</i> o che i messaggi ricevuti abbiano una proprietà configurata <code>msg.parts</code> correttamente.",
		"too-many": "troppi messaggi in sospeso nel nodo Join",
		"type": {
			"array": "un Array",
			"buffer": "un Buffer",
			"merged": "un oggetto unito",
			"object": "un oggetto chiave/valore",
			"string": "una Stringa"
		},
		"using": "utilizzando il valore di"
	},
	"json": {
		"errors": {
			"dropped": "Ignorato tipo di payload non supportato",
			"dropped-error": "Impossibile convertire il payload",
			"dropped-object": "Payload non oggetto ignorato",
			"schema-error": "Errore dello schema JSON",
			"schema-error-compile": "Errore dello schema JSON: impossibile compilare lo schema"
		},
		"label": {
			"action": "Azione",
			"actions": {
				"obj": "Converti sempre in oggetto JavaScript",
				"str": "Converti sempre in stringa JSON",
				"toggle": "Converti tra stringa JSON & oggetto"
			},
			"o2j": "Opzioni da oggetto a JSON",
			"pretty": "Formato stringa JSON",
			"property": "Proprietà"
		}
	},
	"link": {
		"linkIn": "link in",
		"linkOut": "link out"
	},
	"mqtt": {
		"errors": {
			"invalid-json-parse": "Impossibile analizzare la stringa JSON",
			"invalid-json-string": "Stringa JSON non valida",
			"invalid-topic": "Topic non valido",
			"missing-config": "configurazione broker mancante",
			"nonclean-missingclientid": "Nessun Client ID impostato, utilizzando una sessione pulita",
			"not-defined": "topic non definito"
		},
		"false": "falso",
		"label": {
			"broker": "Server",
			"cleansession": "Usare una sessione pulita",
			"cleanstart": "Usa inizio pulito",
			"clientid": "ID Cliente",
			"compatmode": "Utilizzare il supporto MQTT 3.1 legacy",
			"contentType": "Tipo di Contenuto",
			"correlationData": "Dati di correlazione",
			"delay": "Ritardo",
			"example": "es. localhost",
			"expiry": "Scadenza (sec)",
			"flags": "Flag",
			"keepalive": "Mantieni in vita",
			"maximumPacketSize": "Dimensione massima pacchetto",
			"nl": "Non ricevere messaggi pubblicati da questo client",
			"output": "Output",
			"payloadFormatIndicator": "Formato",
			"payloadFormatIndicatorFalse": "byte non specificati (impostazione predefinita)",
			"payloadFormatIndicatorTrue": "Payload codificato UTF-8",
			"port": "Porta",
			"protocolVersion": "Protocollo",
			"protocolVersion3": "MQTT V3.1 (legacy)",
			"protocolVersion4": "MQTT V3.1.1",
			"protocolVersion5": "MQTT V5",
			"qos": "QoS",
			"rap": "Mantieni contrassegno di conservazione della pubblicazione originale",
			"receiveMaximum": "Ricevi Max",
			"responseTopic": "Topic di risposta",
			"retain": "Trattieni",
			"rh": "Gestione dei messaggi conservati ",
			"rh0": "Invia messaggi conservati",
			"rh1": "Invia solo per nuovi abbonamenti",
			"rh2": "Non inviare",
			"session": "Sessione",
			"sessionExpiry": "Scadenza Sessione (sec)",
			"subscriptionIdentifier": "ID Sottoscrizione",
			"tls-config": "Configurazione TLS",
			"topicAlias": "Alias",
			"topicAliasMaximum": "Alias Max",
			"use-tls": "Utilizzare TLS",
			"userProperties": "Proprietà Utente",
			"verify-server-cert": "Verificare il certificato del server"
		},
		"output": {
			"auto": "automatico (stringa o buffer)",
			"base64": "una stringa codificata Base64",
			"buffer": "un Buffer",
			"json": "un oggetto JSON",
			"string": "una Stringa"
		},
		"placeholder": {
			"birth-topic": "Lasciare vuoto per disabilitare il messaggio di nascita",
			"clientid": "Lasciare vuoto per la creazione automatica",
			"clientid-nonclean": "Deve essere impostato per le sessioni non pulite",
			"close-topic": "Lasciare vuoto per disabilitare il messaggio di chiusura",
			"will-topic": "Lascia vuoto per disabilitare il messaggio futuro"
		},
		"retain": "Trattieni",
		"sections-label": {
			"birth-message": "Messaggio inviato alla connessione (messaggio di nascita)",
			"close-message": "Messaggio inviato prima della disconnessione (messaggio di chiusura)",
			"will-message": "Messaggio inviato in caso di disconnessione imprevista (messaggio futuro)"
		},
		"state": {
			"connect-failed": "Connessione fallita al broker: __broker__",
			"connected": "Collegato al broker: __broker__",
			"disconnected": "Disconnesso dal broker: __broker__"
		},
		"tabs-label": {
			"connection": "Connessione",
			"messages": "Messaggi",
			"security": "Sicurezza"
		},
		"tip": "Suggerimento: lasciare vuoto il topic, i qos o conservati se si desidera impostarli tramite le proprietà msg.",
		"true": "vero"
	},
	"range": {
		"errors": {
			"notnumber": "Non un numero"
		},
		"label": {
			"action": "Azione",
			"from": "da",
			"inputrange": "Mappare l'intervallo di input",
			"resultrange": "all'intervallo di destinazione",
			"roundresult": "Arrotondare il risultato all'intero più vicino?",
			"to": "a"
		},
		"placeholder": {
			"maxin": "es. 99",
			"maxout": "es. 255",
			"min": "es. 0"
		},
		"range": "intervallo",
		"scale": {
			"limit": "Scalare e limitare all'intervallo di destinazione",
			"payload": "Ridimensionare la proprietà del messaggio",
			"wrap": "Ridimensionare e avvolgere all'interno dell'intervallo di destinazione"
		},
		"tip": "Suggerimento: questo nodo funziona SOLO con i numeri."
	},
	"rbe": {
		"label": {
			"func": "Modalità",
			"init": "Invia valore iniziale",
			"name": "Nome",
			"septopics": "Applicare la modalità separatamente per ogni ",
			"start": "Valore iniziale"
		},
		"opts": {
			"deadband": "blocca a meno che la modifica del valore non sia maggiore di",
			"deadbandEq": "blocca a meno che la modifica del valore non sia maggiore o uguale a",
			"in": "rispetto all'ultimo valore di input",
			"narrowband": "blocca se la modifica del valore è maggiore di",
			"narrowbandEq": "blocca se la modifica del valore è maggiore o uguale a",
			"out": "rispetto all'ultimo valore di output valido",
			"rbe": "blocca a meno che il valore non cambi",
			"rbei": "blocca a meno che il valore non cambi (ignora il valore iniziale)"
		},
		"placeholder": {
			"bandgap": "es. 10 o 5%",
			"start": "lascia vuoto per utilizzare i primi dati ricevuti"
		},
		"rbe": "filtro",
		"warn": {
			"nonumber": "nessun numero trovato nel payload"
		}
	},
	"sort": {
		"as-number": "come numero",
		"ascending": "crescente",
		"clear": "cancellare il messaggio in sospeso nel nodo di ordinamento",
		"descending": "decrescente",
		"elem": "valore dell'elemento",
		"invalid-exp": "Espressione JSONata non valida nel nodo di ordinamento: __message__",
		"key": "Chiave",
		"order": "Ordina",
		"seq": "sequenza di messaggi",
		"sort": "ordina",
		"target": "Ordina",
		"too-many": "Troppi messaggi in sospeso nel nodo di ordinamento"
	},
	"split": {
		"addname": " Copiare la chiave in ",
		"array": "<b>Array</b>",
		"intro": "Dividi <code>msg.payload</code> in base al tipo:",
		"object": "<b>Oggetto</b>",
		"objectSend": "Inviare un messaggio per ogni coppia chiave/valore",
		"split": "dividi",
		"splitLength": "Lunghezza fissa di",
		"splitUsing": "Dividere usando",
		"strBuff": "<b>Stringa</b> / <b>Buffer</b>",
		"stream": "Gestire come flusso di messaggi"
	},
	"status": {
		"label": {
			"sortByType": "ordina per tipo",
			"source": "Stato del report da"
		},
		"scope": {
			"all": "tutti i nodi",
			"selected": "i nodi selezionati"
		},
		"status": "stato: tutti",
		"statusNodes": "stato: __number__"
	},
	"switch": {
		"and": "e",
		"checkall": "controllo di tutte le regole",
		"errors": {
			"invalid-expr": "Espressione JSONata non valida: __error__",
			"too-many": "troppi messaggi in sospeso nel nodo Switch"
		},
		"ignorecase": "ignora maiuscole/minuscole",
		"label": {
			"property": "Proprietà",
			"repair": "ricreare sequenze di messaggi",
			"rule": "regola"
		},
		"previous": "valore precedente",
		"rules": {
			"btwn": "è tra",
			"cont": "contiene",
			"else": "oppure",
			"empty": "è vuoto",
			"exp": "JSONata exp",
			"false": "è falso",
			"hask": "ha chiave",
			"head": "testata",
			"index": "indice tra",
			"istype": "è di tipo",
			"nempty": "non è vuoto",
			"nnull": "non è nullo",
			"null": "è null",
			"regex": "corrisponde regex",
			"tail": "coda",
			"true": "è vero"
		},
		"stopfirst": "fermarsi dopo aver trovato la prima",
		"switch": "cambia conto"
	},
	"tcpin": {
		"errors": {
			"cannot-listen": "impossibile ascoltare sulla porta __port__, errore: __error__",
			"connect-fail": "connessione non riuscita",
			"connect-timeout": "timeout di connessione",
			"connection-lost": "connessione persa a __host__:__port__",
			"error": "errore: __error__",
			"no-host": "Host e/o porta non impostata",
			"socket-error": "errore socket da __host__:__port__",
			"timeout": "timeout socket chiuso porta __port__"
		},
		"label": {
			"chars": "caratteri",
			"close-connection": "Chiudere la connessione dopo l'invio di ogni messaggio?",
			"decode-base64": "Decodificare il messaggio Base64?",
			"delimited": "delimitato da",
			"host": "presso l'host",
			"ms": "ms",
			"output": "Output",
			"payload": "payload",
			"port": "porta",
			"return": "Ritorno",
			"server": "Server",
			"type": "Tipo"
		},
		"output": {
			"base64": "Stringa Base64",
			"buffer": "Buffer",
			"single": "singola",
			"stream": "flusso di",
			"string": "Stringa"
		},
		"return": {
			"character": "quando il carattere ricevuto è",
			"immed": "immediatamente - non aspettare la risposta",
			"never": "mai - mantenere aperta la connessione",
			"number": "un numero fisso di caratteri",
			"timeout": "dopo un timeout fisso di"
		},
		"status": {
			"connected": "collegato a __host__:__port__",
			"connecting": "connessione a __host__:__port__",
			"connection-closed": "connessione chiusa da __host__:__port__",
			"connection-from": "connessione da __host__:__port__",
			"connections": "__count__ connessione",
			"connections_plural": "__count__ connessioni",
			"listening-port": "ascolto sul port __port__",
			"stopped-listening": "smesso di ascoltare sulla porta"
		},
		"type": {
			"connect": "Connettiti a",
			"listen": "Ascolta su",
			"reply": "Rispondere a TCP"
		}
	},
	"template": {
		"label": {
			"format": "Evidenziazione sintassi",
			"json": "JSON analizzato",
			"mustache": "Modello Mustache",
			"none": "nessuno",
			"output": "Output come",
			"plain": "Testo",
			"property": "Proprietà",
			"syntax": "Formato",
			"template": "Template",
			"yaml": "YAML analizzato"
		},
		"template": "template",
		"templatevalue": "Questo è il payload: {{payload}} !"
	},
	"tls": {
		"error": {
			"missing-file": "Nessun file di certificato/chiave fornito"
		},
		"label": {
			"alpnprotocol": "Protocollo ALPN",
			"ca": "Certificato CA",
			"cert": "Certificato",
			"key": "Chiave Privata",
			"passphrase": "Passphrase",
			"servername": "Nome Server",
			"upload": "Carica",
			"use-local-files": "Usare chiavi e certificati da file locali",
			"verify-server-cert": "Verificare il certificato del server"
		},
		"placeholder": {
			"alpnprotocol": "da utilizzare con ALPN",
			"ca": "percorso del certificato CA (formato PEM)",
			"cert": "percorso del certificato (formato PEM)",
			"key": "percorso della chiave privata (formato PEM)",
			"passphrase": "passphrase a chiave privata (facoltativo)",
			"servername": "da utilizzare con SNI"
		},
		"tls": "Configurazione TLS"
	},
	"trigger": {
		"alltopics": "tutti i messaggi",
		"bytopics": "ogni",
		"duration": {
			"h": "Ore",
			"m": "Minuti",
			"ms": "Millisecondi",
			"s": "Secondi"
		},
		"extend": " prolunga il ritardo in caso di arrivo di un nuovo messaggio",
		"for": "Trattamento",
		"label": {
			"reset": "Reimposta il trigger se:",
			"resetMessage": "msg.reset è impostato",
			"resetPayload": "msg.payload è uguale a",
			"resetprompt": "opzionale",
			"trigger": "trigger",
			"trigger-block": "trigger & blocco",
			"trigger-loop": "rivia ogni"
		},
		"output": {
			"existing": "l'oggetto msg esistente",
			"latest": "l'ultimo oggetto msg",
			"nothing": "niente",
			"number": "il numero",
			"original": "l'oggetto msg originale",
			"string": "la stringa"
		},
		"override": "sovrascri il ritardo con msg.delay",
		"second": " invia un secondo messaggio a un output separato",
		"send": "Invia",
		"then": "poi",
		"then-send": "poi invia",
		"wait-for": "attendi",
		"wait-loop": "rinvialo ogni",
		"wait-reset": "attendi di essere reimpostato"
	},
	"udp": {
		"bcmsg": "messaggio broadcast",
		"bind": {
			"local": "associa a una porta locale",
			"random": "associa a una porta locale casuale",
			"target": "associa alla porta di destinazione"
		},
		"errors": {
			"access-error": "Errore di accesso UDP, potrebbe essere necessario l'accesso root per le porte inferiori a 1024",
			"alreadyused": "udp: porta __port__ già in uso",
			"bad-mcaddress": "Indirizzo multicast non valido",
			"error": "errore: __error__",
			"ifnotfound": "udp: interfaccia __iface__ non trovata",
			"interface": "Deve essere l'indirizzo IP dell'interfaccia richiesta",
			"ip-notset": "udp: indirizzo IP non impostato",
			"port-invalid": "udp: numero di porta non valido",
			"port-notset": "udp: porta non impostata"
		},
		"label": {
			"address": "Indirizzi",
			"decode-base64": "Decodificare il payload codificato Base64?",
			"group": "Gruppo",
			"interface": "IF locale",
			"listen": "Ascolta per",
			"onport": "sulla porta",
			"output": "Output",
			"send": "Inviare un",
			"toport": "alla porta",
			"using": "utilizzando"
		},
		"mcmsg": "messaggio multicast",
		"mcmsgs": "messaggi multicast",
		"output": {
			"base64": "una stringa codificata Base64",
			"buffer": "un Buffer",
			"string": "una Stringa"
		},
		"placeholder": {
			"address": "ip di destinazione",
			"interface": "(facoltativo) interfaccia locale o indirizzo a cui eseguire l'associazione",
			"interfaceprompt": "(facoltativo) interfaccia locale o indirizzo a cui eseguire l'associazione"
		},
		"status": {
			"bc-ready": "broadcast udp pronto: __outport__ -> __host__:__port__",
			"listener-at": "listener udp __host__:__port__",
			"listener-stopped": "listener udp arrestato",
			"mc-group": "gruppo multicast UDP __group__",
			"mc-ready": "udp multicast pronto: __iface__:__outport__ -> __host__:__port__",
			"output-stopped": "output udp arrestato",
			"re-use": "udb riutilizzo socket: __outport__ -> __host__:__port__",
			"ready": "udp pronto: __outport__ -> __host__:__port__",
			"ready-nolocal": "udp pronto: __host__:__port__"
		},
		"tip": {
			"in": "Suggerimento: assicurati che il firewall consenta l'ingresso dei dati.",
			"out": "Suggerimento: lascia vuoto l'indirizzo e la porta se desideri impostarli utilizzando <code>msg.ip</code> e <code>msg.port</code> .",
			"port": "Porte già in uso: "
		},
		"udpmsg": "messaggio udp",
		"udpmsgs": "messaggi udp"
	},
	"unknown": {
		"label": {
			"unknown": "sconosciuto"
		},
		"tip": "<p>Questo nodo è un tipo sconosciuto all'installazione di Node-RED.</p><p><i>Se si distribuisce con il nodo in questo stato, la configurazione verrà mantenuta, ma il flusso non verrà avviato fino a quando non viene installato il tipo mancante.</i></p><p>Per altre informazioni, vedere la barra laterale Info</p>"
	},
	"watch": {
		"label": {
			"files": "File",
			"recursive": "Controlla le sotto cartelle in modo ricorsivo"
		},
		"placeholder": {
			"files": "Elenco delimitato da virgole di file e/o cartelle"
		},
		"tip": "In Windows è necessario utilizzare doppi back-slashes\\\\ in tutti i nomi di cartelle.",
		"watch": "watch"
	},
	"websocket": {
		"connectto": "Connettiti a",
		"errors": {
			"connect-error": "Si è verificato un errore sulla connessione ws: ",
			"duplicate-path": "Non è possibile avere due listener WebSocket sullo stesso percorso: __path__",
			"missing-conf": "Configurazione del server mancante",
			"send-error": "Si è verificato un errore durante l'invio: "
		},
		"label": {
			"path": "Path",
			"type": "Tipo",
			"url": "URL"
		},
		"listenon": "Ascolta su",
		"message": "intero messaggio",
		"payload": "portata utile",
		"sendheartbeat": "Invia heartbeat",
		"sendrec": "Invio/ricezione",
		"status": {
			"connected": "connessione __count__",
			"connected_plural": "connessione __count__"
		},
		"tip": {
			"path1": "Per impostazione predefinita, <code>payload</code> conterrà i dati da inviare o ricevere da un websocket. Il listener può essere configurato per inviare o ricevere l'intero oggetto messaggio come stringa in formato JSON.",
			"path2": "Questo percorso sarà relativo a <code>__path__</code> .",
			"url1": "L'URL deve usare lo schema ws:// o wss:// e puntare a un listener websocket esistente.",
			"url2": "Per impostazione predefinita, <code>payload</code> conterrà i dati da inviare o ricevere da un websocket. Il client può essere configurato per inviare o ricevere l'intero oggetto messaggio come stringa in formato JSON."
		}
	},
	"xml": {
		"errors": {
			"xml_js": "Questo nodo gestisce solo stringhe xml o oggetti js."
		},
		"label": {
			"advanced": "Opzioni avanzate",
			"prefix": "Nome della proprietà per il contenuto del testo del tag",
			"represent": "Nome della proprietà per gli attributi dei tag XML",
			"x2o": "Opzioni da XML a oggetto"
		}
	},
	"yaml": {
		"errors": {
			"dropped": "Ignorato tipo di payload non supportato",
			"dropped-error": "Impossibile convertire il payload",
			"dropped-object": "Ignorato payload non oggetto"
		}
	}
}
